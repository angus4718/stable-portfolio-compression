{
  "description": "Configuration for basis asset selection from synthetic price data",
  
  "input": {
    "prices_path": {
      "value": "synthetic_data/prices_monthly.csv",
      "description": "Path to the monthly prices CSV file (generated by generate_synthetic_data.py)",
      "type": "string"
    },
    "weights_path": {
      "value": "synthetic_data/market_index_weights.csv",
      "description": "Path to the market index weights CSV file. Assets with positive weights in any month are retained.",
      "type": "string"
    }
  },

  "distance_computation": {
    "description": "Parameters for computing distance matrix from prices",
    
    "corr_method": {
      "value": "pearson",
      "description": "Correlation method to use ('pearson' or 'spearman')",
      "type": "string",
      "options": ["pearson", "spearman"]
    },
    
    "min_periods": {
      "value": 1,
      "description": "Minimum number of overlapping observations required to compute correlation",
      "type": "integer",
      "min": 1
    },
    
    "shrink_method": {
      "value": "pca",
      "description": "Covariance/correlation shrinkage method (None for raw, 'lw' for Ledoit-Wolf, 'pca' for PCA denoising)",
      "type": "string",
      "options": [null, "lw", "pca"]
    }
  },

  "pca_denoising": {
    "description": "Parameters for PCA denoising when shrink_method='pca'",
    
    "pca_n_components": {
      "value": null,
      "description": "Number of PCA components to retain (null = auto-select based on explained_variance)",
      "type": ["integer", "null"],
      "min": 1
    },
    
    "pca_explained_variance": {
      "value": 0.75,
      "description": "Target explained variance ratio for PCA (0.0 to 1.0). Used if pca_n_components is null.",
      "type": "float",
      "min": 0.0,
      "max": 1.0
    }
  },

  "basis_selection": {
    "description": "Parameters for basis asset selection. Choose method via 'basis_selection_method'. Supported: 'max_spread', 'max_spread_weighted', 'hub_branch', 'error_driven'",

    "basis_size": {
      "value": 10,
      "description": "Number of basis assets to select",
      "type": "integer",
      "min": 1
    },

    "basis_selection_method": {
      "value": "error_driven",
      "description": "Basis selection algorithm. Options: 'max_spread', 'max_spread_weighted', 'hub_branch', 'error_driven'",
      "type": "string",
      "options": ["max_spread", "max_spread_weighted", "hub_branch", "error_driven"]
    },

    "use_weighted_selection": {
      "value": true,
      "description": "Whether to incorporate stock weights (market importance) into selection (used by weighted methods)",
      "type": "boolean"
    },

    "weight_alpha": {
      "value": 0.5,
      "description": "Trade-off parameter for weighted selection: balances spread vs weight importance (used by max_spread_weighted)",
      "type": "float",
      "min": 0.0,
      "max": 1.0,
      "notes": {
        "0.0": "Pure weight-based selection (picks highest-weight stocks)",
        "0.5": "Balanced: equal emphasis on spread and weight",
        "1.0": "Pure spread-based selection (ignores weights, same as standard max-spread)"
      }
    },

    "hub_branch_h": {
      "value": null,
      "description": "Number of hubs for hub_branch (null=auto, integer to override)",
      "type": ["integer", "null"]
    },
    "hub_branch_alpha": {
      "value": 0.5,
      "description": "Centrality trade-off for hub_branch: 0=betweenness, 1=degree",
      "type": "float",
      "min": 0.0,
      "max": 1.0
    },
    "hub_branch_weight_gamma": {
      "value": 0.0,
      "description": "Weight blending for hub_branch: 0=centrality only, 1=weight only",
      "type": "float",
      "min": 0.0,
      "max": 1.0
    },
    "hub_branch_rep_alpha": {
      "value": 0.5,
      "description": "Branch representative trade-off: 0=weight, 1=distance",
      "type": "float",
      "min": 0.0,
      "max": 1.0
    },

    "error_driven_gamma": {
      "value": 0.0,
      "description": "Turnover penalty for error_driven (0=none)",
      "type": "float",
      "min": 0.0
    },
    "error_driven_weight_beta": {
      "value": 0.0,
      "description": "Weight bias for error_driven (0=none)",
      "type": "float"
    }
  },

  "output": {
    "output_path": {
      "value": "synthetic_data/basis_selected.csv",
      "description": "Path where the selected basis tickers will be saved",
      "type": "string"
    },
    "basis_path": {
      "value": "synthetic_data/basis_selected.csv",
      "description": "Path to the basis CSV (used by local_ridge). Can override default location.",
      "type": "string"
    },
    
    "file_format": {
      "value": "csv",
      "description": "Output format for basis selection results",
      "type": "string"
    }
  },

  "regression": {
    "description": "Parameters for local regression post-processing",
    "ridge_alpha": {
      "value": 1.0,
      "description": "Regularization strength for Ridge regression (alpha).",
      "type": "float",
      "min": 0.0
    }
    ,
    "q_neighbors": {
      "value": 3,
      "description": "Number of nearest basis neighbors to use per regression (null = use all basis assets)",
      "type": ["integer", "null"],
      "min": 1
    }
  },

  "mst": {
    "description": "Minimum Spanning Tree parameters",
    
    "algorithm": {
      "value": "prim",
      "description": "MST algorithm to use ('prim' is currently implemented)",
      "type": "string",
      "options": ["prim"]
    }
  },

  "notes": {
    "workflow": [
      "1. Load monthly price data from prices_path",
      "2. Compute pairwise correlations using corr_method",
      "3. Apply shrinkage/denoising (if specified)",
      "4. Convert correlations to distances using chord distance: d = sqrt(2(1 - rho))",
      "5. Build minimum spanning tree from distance matrix using Prim's algorithm",
      "6. Select basis_size assets using max-spread (greedy k-center) on MST",
      "7. Save selected basis tickers to output_path"
    ],
    "shrink_methods": {
      "None": "Use raw sample correlation (no shrinkage)",
      "lw": "Ledoit-Wolf shrinkage toward diagonal target (uses sklearn)",
      "pca": "PCA-based denoising with top-k component retention"
    },
    "distance_metric": "Chord distance: d_ij = sqrt(2 * (1 - rho_ij))",
    "basis_selection_algorithm": "Gonzalez greedy k-center algorithm on MST",
    "typical_use_cases": [
      {
        "name": "Conservative (low denoising)",
        "shrink_method": null,
        "basis_size": 5,
        "description": "Use raw correlations for detailed structure preservation"
      },
      {
        "name": "Moderate (Ledoit-Wolf)",
        "shrink_method": "lw",
        "basis_size": 10,
        "description": "Use Ledoit-Wolf shrinkage for balanced denoising"
      },
      {
        "name": "Aggressive (PCA denoising)",
        "shrink_method": "pca",
        "pca_explained_variance": 0.75,
        "basis_size": 15,
        "description": "Use PCA to denoise, retaining 75% of variance"
      }
    ]
  }
}
